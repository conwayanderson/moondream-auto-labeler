"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.vl = void 0;
const buffer_1 = require("buffer");
const sharp_1 = __importDefault(require("sharp"));
const http_1 = __importDefault(require("http"));
const https_1 = __importDefault(require("https"));
const package_json_1 = require("../package.json");
const DEFAULT_ENDPOINT = 'https://api.moondream.ai/v1';
class vl {
    constructor(config) {
        this.apiKey = config.apiKey || '';
        this.endpoint = config.endpoint || DEFAULT_ENDPOINT;
        if (this.apiKey === '' && this.endpoint === DEFAULT_ENDPOINT) {
            throw new Error('An apiKey is required for cloud inference. ');
        }
    }
    async encodeImage(image) {
        if ('imageUrl' in image) {
            return image;
        }
        try {
            // Process image with Sharp
            const metadata = await (0, sharp_1.default)(image).metadata();
            if (!metadata.width || !metadata.height) {
                throw new Error('Unable to get image dimensions');
            }
            let processedImage = (0, sharp_1.default)(image);
            const buffer = await processedImage
                .toFormat('jpeg', { quality: 95 })
                .toBuffer();
            const base64Image = buffer.toString('base64');
            return {
                imageUrl: `data:image/jpeg;base64,${base64Image}`,
            };
        }
        catch (error) {
            throw new Error(`Failed to convert image to JPEG: ${error.message}`);
        }
    }
    makeRequest(path, body, stream = false) {
        return new Promise((resolve, reject) => {
            const url = new URL(this.endpoint + path);
            const requestBody = JSON.stringify(body);
            const options = {
                method: 'POST',
                headers: {
                    'X-Moondream-Auth': this.apiKey,
                    'Content-Type': 'application/json',
                    'User-Agent': `moondream-node/${package_json_1.version}`,
                    'Content-Length': buffer_1.Buffer.byteLength(requestBody)
                }
            };
            const client = url.protocol === 'https:' ? https_1.default : http_1.default;
            const req = client.request(url, options, (res) => {
                if (stream) {
                    resolve(res);
                    return;
                }
                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => {
                    if (res.statusCode !== 200) {
                        reject(new Error(`HTTP error! status: ${res.statusCode}`));
                        return;
                    }
                    try {
                        resolve(JSON.parse(data));
                    }
                    catch (error) {
                        reject(new Error(`Failed to parse JSON response: ${error.message}`));
                    }
                });
            });
            req.on('error', (error) => {
                reject(error);
            });
            req.write(requestBody);
            req.end();
        });
    }
    async *streamResponse(response) {
        let buffer = '';
        try {
            for await (const chunk of response) {
                buffer += chunk.toString();
                const lines = buffer.split('\n');
                buffer = lines.pop() || '';
                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        try {
                            const data = JSON.parse(line.slice(6));
                            if ('chunk' in data) {
                                yield data.chunk;
                            }
                            if (data.completed) {
                                return;
                            }
                        }
                        catch (error) {
                            throw new Error(`Failed to parse JSON response from server: ${error.message}`);
                        }
                    }
                }
            }
            // Handle any remaining data in the buffer
            if (buffer) {
                const lines = buffer.split('\n');
                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        try {
                            const data = JSON.parse(line.slice(6));
                            if ('chunk' in data) {
                                yield data.chunk;
                            }
                        }
                        catch (error) {
                            throw new Error(`Failed to parse JSON response from server: ${error.message}`);
                        }
                    }
                }
            }
        }
        catch (error) {
            throw new Error(`Failed to stream response: ${error.message}`);
        }
    }
    async caption(request) {
        const encodedImage = await this.encodeImage(request.image);
        const requestBody = {
            image_url: encodedImage.imageUrl,
            length: request.length,
            stream: request.stream,
        };
        if (request.variant) {
            requestBody.variant = request.variant;
        }
        const response = await this.makeRequest('/caption', requestBody, request.stream);
        if (request.stream) {
            return { caption: this.streamResponse(response) };
        }
        return { caption: response.caption };
    }
    async query(request) {
        let requestBody = {
            question: request.question,
            stream: request.stream,
        };
        if (request.image) {
            const encodedImage = await this.encodeImage(request.image);
            requestBody.image_url = encodedImage.imageUrl;
        }
        if (request.reasoning !== undefined) {
            requestBody.reasoning = request.reasoning;
        }
        if (request.variant) {
            requestBody.variant = request.variant;
        }
        const response = await this.makeRequest('/query', requestBody, request.stream);
        if (request.stream) {
            return { answer: this.streamResponse(response) };
        }
        const result = { answer: response.answer };
        if (response.reasoning) {
            result.reasoning = response.reasoning;
        }
        return result;
    }
    async detect(request) {
        const encodedImage = await this.encodeImage(request.image);
        const requestBody = {
            image_url: encodedImage.imageUrl,
            object: request.object,
        };
        if (request.variant) {
            requestBody.variant = request.variant;
        }
        const response = await this.makeRequest('/detect', requestBody);
        return { objects: response.objects };
    }
    async point(request) {
        const encodedImage = await this.encodeImage(request.image);
        const requestBody = {
            image_url: encodedImage.imageUrl,
            object: request.object,
        };
        if (request.variant) {
            requestBody.variant = request.variant;
        }
        const response = await this.makeRequest('/point', requestBody);
        return { points: response.points };
    }
}
exports.vl = vl;
